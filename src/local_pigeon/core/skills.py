"""
Skills Manager

Manages learned skills that help the model use tools correctly.
Skills are learned patterns that can be:
- Created manually (pre-defined)
- Generated by the RALPH loop when tool usage fails
- Written by the agent itself (markdown format)
- Updated based on feedback

Skills can be stored as:
- YAML files (legacy/programmatic)
- Markdown files (human-readable, agent-writable)

Markdown skills use frontmatter for metadata and body for instructions.
"""

import json
import re
import yaml
from dataclasses import dataclass, field, asdict
from datetime import datetime
from pathlib import Path
from typing import Any

from local_pigeon.config import get_data_dir


@dataclass
class Skill:
    """
    A learned skill for using a specific tool.
    
    Attributes:
        id: Unique identifier
        name: Human-readable name  
        tool: The tool this skill applies to
        triggers: Phrases/patterns that should trigger this tool
        examples: Example user inputs and expected tool calls
        instructions: Natural language instructions for the model
        created_at: When this skill was created
        updated_at: Last update timestamp
        source: 'manual', 'ralph_loop', 'agent', 'heartbeat'
        success_count: How many times this skill led to successful tool use
        failure_count: How many times this skill still failed
        status: 'approved', 'pending', 'rejected'
    """
    id: str
    name: str
    tool: str
    triggers: list[str] = field(default_factory=list)
    examples: list[dict[str, Any]] = field(default_factory=list)
    instructions: str = ""
    created_at: str = ""
    updated_at: str = ""
    source: str = "manual"
    success_count: int = 0
    failure_count: int = 0
    enabled: bool = True
    status: str = "approved"  # approved, pending, rejected


class SkillsManager:
    """
    Manages the skills directory and skill files.
    
    Skills are stored as YAML or Markdown files in:
    - {data_dir}/skills/builtin/  - Pre-defined skills (read-only)
    - {data_dir}/skills/learned/  - Skills learned by RALPH loop
    - {data_dir}/skills/custom/   - User-defined custom skills
    - {data_dir}/skills/pending/  - Agent-proposed skills awaiting approval
    """
    
    def __init__(self, data_dir: Path | None = None):
        self.data_dir = data_dir or get_data_dir()
        self.skills_dir = self.data_dir / "skills"
        self._ensure_directories()
        self._skills_cache: dict[str, Skill] = {}
        self._pending_cache: dict[str, Skill] = {}
        self._loaded = False
    
    def _ensure_directories(self) -> None:
        """Create skills directories if they don't exist."""
        (self.skills_dir / "builtin").mkdir(parents=True, exist_ok=True)
        (self.skills_dir / "learned").mkdir(parents=True, exist_ok=True)
        (self.skills_dir / "custom").mkdir(parents=True, exist_ok=True)
        (self.skills_dir / "pending").mkdir(parents=True, exist_ok=True)
        
        # Create default skills if they don't exist
        self._create_default_skills()
    
    def _create_default_skills(self) -> None:
        """Create default builtin skills."""
        builtin_dir = self.skills_dir / "builtin"
        
        # Gmail skill
        gmail_skill_path = builtin_dir / "gmail.yaml"
        if not gmail_skill_path.exists():
            gmail_skill = Skill(
                id="gmail_read",
                name="Read Gmail",
                tool="gmail",
                triggers=[
                    "check my email",
                    "what are my emails",
                    "show my inbox",
                    "any new emails",
                    "latest emails",
                    "read my mail",
                    "what's in my inbox",
                    "do I have emails",
                    "unread emails",
                    "recent emails",
                ],
                examples=[
                    {
                        "user": "what are my latest 5 emails?",
                        "tool_call": {"name": "gmail", "arguments": {"action": "list", "max_results": 5}},
                    },
                    {
                        "user": "check my email",
                        "tool_call": {"name": "gmail", "arguments": {"action": "list"}},
                    },
                    {
                        "user": "find emails from Amazon",
                        "tool_call": {"name": "gmail", "arguments": {"action": "search", "query": "from:Amazon"}},
                    },
                ],
                instructions=(
                    "When the user asks about their email, inbox, or mail, ALWAYS use the gmail tool. "
                    "Use action='list' to show recent emails. Use action='search' with a query to find specific emails. "
                    "Never say you cannot access email - the gmail tool is integrated and ready to use."
                ),
                created_at=datetime.now().isoformat(),
                updated_at=datetime.now().isoformat(),
                source="builtin",
            )
            self._save_skill(gmail_skill, gmail_skill_path)
        
        # Calendar skill
        calendar_skill_path = builtin_dir / "calendar.yaml"
        if not calendar_skill_path.exists():
            calendar_skill = Skill(
                id="calendar_read",
                name="Read Calendar",
                tool="calendar",
                triggers=[
                    "my calendar",
                    "my schedule",
                    "what's on my calendar",
                    "meetings today",
                    "upcoming events",
                    "am I free",
                    "what do I have",
                    "appointments",
                ],
                examples=[
                    {
                        "user": "what's on my calendar today?",
                        "tool_call": {"name": "calendar", "arguments": {"action": "list"}},
                    },
                    {
                        "user": "am I free tomorrow at 2pm?",
                        "tool_call": {"name": "calendar", "arguments": {"action": "free", "date": "tomorrow", "time": "2pm"}},
                    },
                ],
                instructions=(
                    "When the user asks about their calendar, schedule, events, or meetings, ALWAYS use the calendar tool. "
                    "Use action='list' to show upcoming events. Use action='free' to check availability."
                ),
                created_at=datetime.now().isoformat(),
                updated_at=datetime.now().isoformat(),
                source="builtin",
            )
            self._save_skill(calendar_skill, calendar_skill_path)
        
        # Web search skill
        search_skill_path = builtin_dir / "web_search.yaml"
        if not search_skill_path.exists():
            search_skill = Skill(
                id="web_search",
                name="Web Search",
                tool="web_search",
                triggers=[
                    "search for",
                    "look up",
                    "find information about",
                    "what is the weather",
                    "current news",
                    "stock price",
                    "latest on",
                ],
                examples=[
                    {
                        "user": "what's the weather today?",
                        "tool_call": {"name": "web_search", "arguments": {"query": "weather today"}},
                    },
                    {
                        "user": "search for python tutorials",
                        "tool_call": {"name": "web_search", "arguments": {"query": "python tutorials"}},
                    },
                ],
                instructions=(
                    "When the user asks about current events, weather, news, prices, or anything that requires "
                    "up-to-date information, use the web_search tool to find the answer."
                ),
                created_at=datetime.now().isoformat(),
                updated_at=datetime.now().isoformat(),
                source="builtin",
            )
            self._save_skill(search_skill, search_skill_path)
    
    def _save_skill(self, skill: Skill, path: Path) -> None:
        """Save a skill to a YAML file."""
        with open(path, "w", encoding="utf-8") as f:
            yaml.dump(asdict(skill), f, default_flow_style=False, allow_unicode=True)
    
    def _save_skill_md(self, skill: Skill, path: Path) -> None:
        """Save a skill as a Markdown file with frontmatter."""
        # Generate triggers list
        triggers_md = "\n".join(f"- {t}" for t in skill.triggers) if skill.triggers else "- (add trigger phrases)"
        
        # Generate examples
        examples_md = ""
        for ex in skill.examples:
            examples_md += f"\n**User:** \"{ex.get('user', '')}\"\n"
            examples_md += f"**Action:** `{json.dumps(ex.get('tool_call', {}))}`\n"
        if not examples_md:
            examples_md = "\n**User:** \"example request\"\n**Action:** `{\"name\": \"tool_name\", \"arguments\": {}}`\n"
        
        content = f"""---
id: {skill.id}
name: {skill.name}
tool: {skill.tool}
status: {skill.status}
source: {skill.source}
created: {skill.created_at}
updated: {skill.updated_at}
success_count: {skill.success_count}
failure_count: {skill.failure_count}
---

# {skill.name}

## Description
{skill.instructions}

## Triggers
When the user says phrases like:
{triggers_md}

## Instructions
{skill.instructions}

## Examples
{examples_md}
"""
        path.write_text(content, encoding="utf-8")
    
    def _load_skill(self, path: Path) -> Skill | None:
        """Load a skill from a YAML file."""
        try:
            with open(path, "r", encoding="utf-8") as f:
                data = yaml.safe_load(f)
                return Skill(**data)
        except Exception as e:
            print(f"Error loading skill from {path}: {e}")
            return None
    
    def _load_skill_md(self, path: Path) -> Skill | None:
        """Load a skill from a Markdown file with frontmatter."""
        try:
            content = path.read_text(encoding="utf-8")
            
            # Parse frontmatter (between --- markers)
            frontmatter_match = re.match(r'^---\s*\n(.*?)\n---\s*\n', content, re.DOTALL)
            if not frontmatter_match:
                return None
                
            frontmatter = yaml.safe_load(frontmatter_match.group(1))
            body = content[frontmatter_match.end():]
            
            # Parse triggers from body
            triggers = []
            triggers_match = re.search(r'## Triggers.*?\n((?:- .*\n)+)', body, re.IGNORECASE)
            if triggers_match:
                triggers = [
                    line.strip()[2:].strip()
                    for line in triggers_match.group(1).strip().split("\n")
                    if line.strip().startswith("-")
                ]
            
            # Parse instructions from body
            instructions = frontmatter.get("instructions", "")
            instructions_match = re.search(r'## Instructions\s*\n(.*?)(?=\n## |$)', body, re.DOTALL | re.IGNORECASE)
            if instructions_match:
                instructions = instructions_match.group(1).strip()
            
            # Parse examples
            examples = []
            examples_match = re.search(r'## Examples\s*\n(.*?)(?=\n## |$)', body, re.DOTALL | re.IGNORECASE)
            if examples_match:
                example_text = examples_match.group(1)
                # Simple parsing: look for User/Action pairs
                user_matches = re.findall(r'\*\*User:\*\*\s*"([^"]*)"', example_text)
                action_matches = re.findall(r'\*\*Action:\*\*\s*`([^`]*)`', example_text)
                for user, action in zip(user_matches, action_matches):
                    try:
                        examples.append({
                            "user": user,
                            "tool_call": json.loads(action) if action.startswith("{") else {"name": action},
                        })
                    except json.JSONDecodeError:
                        examples.append({"user": user, "tool_call": {"name": action}})
            
            return Skill(
                id=frontmatter.get("id", path.stem),
                name=frontmatter.get("name", path.stem),
                tool=frontmatter.get("tool", "unknown"),
                triggers=triggers or frontmatter.get("triggers", []),
                examples=examples,
                instructions=instructions,
                created_at=str(frontmatter.get("created", "")),
                updated_at=str(frontmatter.get("updated", "")),
                source=frontmatter.get("source", "markdown"),
                success_count=frontmatter.get("success_count", 0),
                failure_count=frontmatter.get("failure_count", 0),
                status=frontmatter.get("status", "approved"),
                enabled=frontmatter.get("status", "approved") == "approved",
            )
            
        except Exception as e:
            print(f"Error loading markdown skill from {path}: {e}")
            return None
    
    def load_all_skills(self) -> dict[str, Skill]:
        """Load all approved skills from all directories."""
        self._skills_cache = {}
        self._pending_cache = {}
        
        for category in ["builtin", "learned", "custom"]:
            category_dir = self.skills_dir / category
            if category_dir.exists():
                # Load YAML skills
                for skill_file in category_dir.glob("*.yaml"):
                    skill = self._load_skill(skill_file)
                    if skill and skill.enabled and skill.status == "approved":
                        self._skills_cache[skill.id] = skill
                
                # Load Markdown skills
                for skill_file in category_dir.glob("*.md"):
                    skill = self._load_skill_md(skill_file)
                    if skill and skill.enabled and skill.status == "approved":
                        self._skills_cache[skill.id] = skill
        
        # Load pending skills separately
        pending_dir = self.skills_dir / "pending"
        if pending_dir.exists():
            for skill_file in pending_dir.glob("*.md"):
                skill = self._load_skill_md(skill_file)
                if skill:
                    self._pending_cache[skill.id] = skill
            for skill_file in pending_dir.glob("*.yaml"):
                skill = self._load_skill(skill_file)
                if skill:
                    self._pending_cache[skill.id] = skill
        
        self._loaded = True
        return self._skills_cache
    
    def get_pending_skills(self) -> list[Skill]:
        """Get all skills pending approval."""
        if not self._loaded:
            self.load_all_skills()
        return list(self._pending_cache.values())
    
    def approve_skill(self, skill_id: str) -> bool:
        """Approve a pending skill, moving it to learned."""
        pending_dir = self.skills_dir / "pending"
        learned_dir = self.skills_dir / "learned"
        
        # Find the pending skill file
        for ext in [".md", ".yaml"]:
            pending_path = pending_dir / f"{skill_id}{ext}"
            if pending_path.exists():
                # Load, update status, and save to learned
                if ext == ".md":
                    skill = self._load_skill_md(pending_path)
                else:
                    skill = self._load_skill(pending_path)
                    
                if skill:
                    skill.status = "approved"
                    skill.enabled = True
                    skill.updated_at = datetime.now().isoformat()
                    
                    # Save to learned directory
                    new_path = learned_dir / f"{skill_id}.md"
                    self._save_skill_md(skill, new_path)
                    
                    # Remove from pending
                    pending_path.unlink()
                    
                    # Update caches
                    self._skills_cache[skill_id] = skill
                    self._pending_cache.pop(skill_id, None)
                    
                    return True
        return False
    
    def reject_skill(self, skill_id: str) -> bool:
        """Reject a pending skill, deleting it."""
        pending_dir = self.skills_dir / "pending"
        
        for ext in [".md", ".yaml"]:
            pending_path = pending_dir / f"{skill_id}{ext}"
            if pending_path.exists():
                pending_path.unlink()
                self._pending_cache.pop(skill_id, None)
                return True
        return False
    
    def get_skill(self, skill_id: str) -> Skill | None:
        """Get a specific skill by ID."""
        if not self._loaded:
            self.load_all_skills()
        return self._skills_cache.get(skill_id)
    
    def get_skills_for_tool(self, tool_name: str) -> list[Skill]:
        """Get all skills that apply to a specific tool."""
        if not self._loaded:
            self.load_all_skills()
        return [s for s in self._skills_cache.values() if s.tool == tool_name]
    
    def get_all_skills(self) -> list[Skill]:
        """Get all enabled skills."""
        if not self._loaded:
            self.load_all_skills()
        return list(self._skills_cache.values())
    
    def find_matching_skills(self, user_message: str) -> list[Skill]:
        """
        Find skills whose triggers match the user's message.
        
        Returns skills sorted by relevance (most triggers matched first).
        """
        if not self._loaded:
            self.load_all_skills()
        
        user_lower = user_message.lower()
        matches = []
        
        for skill in self._skills_cache.values():
            match_count = sum(1 for trigger in skill.triggers if trigger.lower() in user_lower)
            if match_count > 0:
                matches.append((skill, match_count))
        
        # Sort by match count descending
        matches.sort(key=lambda x: x[1], reverse=True)
        return [skill for skill, _ in matches]
    
    def add_learned_skill(self, skill: Skill) -> Path:
        """
        Add a new learned skill from the RALPH loop.
        
        Returns the path where the skill was saved.
        """
        skill.source = "ralph_loop"
        skill.created_at = datetime.now().isoformat()
        skill.updated_at = datetime.now().isoformat()
        
        # Generate filename from skill ID
        filename = f"{skill.id}.yaml"
        path = self.skills_dir / "learned" / filename
        
        self._save_skill(skill, path)
        self._skills_cache[skill.id] = skill
        
        return path
    
    def update_skill(self, skill_id: str, updates: dict[str, Any]) -> bool:
        """
        Update an existing skill.
        
        Returns True if successful, False if skill not found.
        """
        skill = self.get_skill(skill_id)
        if not skill:
            return False
        
        # Find the skill file
        for category in ["learned", "custom", "builtin"]:
            path = self.skills_dir / category / f"{skill_id}.yaml"
            if path.exists():
                # Apply updates
                for key, value in updates.items():
                    if hasattr(skill, key):
                        setattr(skill, key, value)
                
                skill.updated_at = datetime.now().isoformat()
                self._save_skill(skill, path)
                self._skills_cache[skill_id] = skill
                return True
        
        return False
    
    def record_skill_usage(self, skill_id: str, success: bool) -> None:
        """Record whether a skill led to successful tool usage."""
        skill = self.get_skill(skill_id)
        if skill:
            if success:
                self.update_skill(skill_id, {"success_count": skill.success_count + 1})
            else:
                self.update_skill(skill_id, {"failure_count": skill.failure_count + 1})
    
    def get_skill_prompt_section(self, user_message: str | None = None) -> str:
        """
        Generate a prompt section containing relevant skills.
        
        If user_message is provided, only include matching skills.
        Otherwise, include all skills.
        """
        if user_message:
            skills = self.find_matching_skills(user_message)
        else:
            skills = self.get_all_skills()
        
        if not skills:
            return ""
        
        lines = ["\n## Learned Skills\n"]
        lines.append("Use these skills to correctly call tools:\n")
        
        for skill in skills[:5]:  # Limit to top 5 relevant skills
            lines.append(f"### {skill.name} ({skill.tool} tool)")
            lines.append(f"{skill.instructions}\n")
            
            if skill.examples:
                lines.append("Examples:")
                for example in skill.examples[:2]:  # Max 2 examples per skill
                    lines.append(f"  User: \"{example['user']}\"")
                    lines.append(f"  Tool call: {json.dumps(example['tool_call'])}")
                lines.append("")
        
        return "\n".join(lines)
    
    def export_skills(self, output_path: Path) -> None:
        """Export all skills to a single JSON file."""
        skills = self.get_all_skills()
        data = [asdict(s) for s in skills]
        
        with open(output_path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2)
    
    def import_skills(self, input_path: Path, category: str = "custom") -> int:
        """
        Import skills from a JSON file.
        
        Returns the number of skills imported.
        """
        with open(input_path, "r", encoding="utf-8") as f:
            data = json.load(f)
        
        count = 0
        for skill_data in data:
            skill = Skill(**skill_data)
            skill.source = "imported"
            
            path = self.skills_dir / category / f"{skill.id}.yaml"
            self._save_skill(skill, path)
            self._skills_cache[skill.id] = skill
            count += 1
        
        return count
